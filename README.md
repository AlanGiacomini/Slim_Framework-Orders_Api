# üìò README - API de Gerenciamento de Pedidos com Slim Framework

## üìë Sum√°rio

- [üì¶ Sobre o Projeto](#-sobre-o-projeto)
- [üöÄ Tecnologias Utilizadas](#-tecnologias-utilizadas)
- [üõ†Ô∏è Estrutura do Projeto](#Ô∏è-estrutura-do-projeto)
- [üìù Entreg√°veis](#-entreg√°veis)
- [üìñ Instru√ß√µes de Execu√ß√£o do Projeto](#-instru√ß√µes-de-execu√ß√£o-do-projeto)
- [üìÑ Documenta√ß√£o da API](#-documenta√ß√£o-da-api)
- [üß† Decis√µes T√©cnicas](#-decis√µes-t√©cnicas)
- [üîí Diferenciais Implementados](#-diferenciais-implementados)

## üì¶ Sobre o Projeto

O objetivo √© construir uma API REST para gerenciamento de pedidos de venda, com processamento ass√≠ncrono de atualiza√ß√µes de status e notifica√ß√µes via RabbitMQ.

## üöÄ Tecnologias Utilizadas

- PHP com Slim Framework
- MySQL
- RabbitMQ
- Swagger / OpenAPI
- Docker Compose

## üõ†Ô∏è Estrutura do Projeto
> A fim de manter a separa√ß√£o visual entre c√≥digo fonte e documentos do projeto, foi criada a pasta `0 - DOCUMENTOS DO PROJETO`. Nela est√£o contidos os documentos gerados ao longo do desenvolvimento e o `Plano de Trabalho` proposto.

```
‚îÇ   .env
‚îÇ   .gitignore
‚îÇ   composer.json
‚îÇ   composer.lock
‚îÇ   docker-compose.yml
‚îÇ   Dockerfile
‚îÇ   migrate.php
‚îÇ   README.md
‚îÇ
‚îú‚îÄ‚îÄ‚îÄDOCUMENTOS DO PROJETO
‚îÇ       Colletion-Desafio-iPag-Alan.postman_collection.json
‚îÇ       Documento_API.md
‚îÇ       Enunciado_Desafio.md
‚îÇ       Estrutura de Arquivos.md
‚îÇ       Plano de Trabalho - Desafio iPag - Alan Giacomini.pdf
‚îÇ       Plano Desafio.md
‚îÇ
‚îú‚îÄ‚îÄ‚îÄapp
‚îÇ   ‚îÇ   SwaggerBase.php
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄControllers
‚îÇ   ‚îÇ       AuthController.php
‚îÇ   ‚îÇ       HealthController.php
‚îÇ   ‚îÇ       OrderController.php
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄMiddleware
‚îÇ   ‚îÇ       ApiKeyMiddleware.php
‚îÇ   ‚îÇ       JwtMiddleware.php
‚îÇ   ‚îÇ       RateLimitMiddleware.php
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄModels
‚îÇ   ‚îÇ       Customer.php
‚îÇ   ‚îÇ       NotificationLog.php
‚îÇ   ‚îÇ       Order.php
‚îÇ   ‚îÇ       OrderItem.php
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄServices
‚îÇ   ‚îÇ       OrderService.php
‚îÇ   ‚îÇ       QueueService.php
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄUtils
‚îÇ           Validator.php
‚îÇ
‚îú‚îÄ‚îÄ‚îÄconfig
‚îÇ       conteiner.php
‚îÇ       database.php
‚îÇ
‚îú‚îÄ‚îÄ‚îÄlogs
‚îú‚îÄ‚îÄ‚îÄmigrations
‚îÇ       202508241600_create_customers_table.php
‚îÇ       202508241605_create_orders_table.php
‚îÇ       202508241610_create_notification_logs_table.php
‚îÇ       202508241615_create_order_items_table.php
‚îÇ
‚îú‚îÄ‚îÄ‚îÄpublic
‚îÇ   ‚îÇ   .htaccess
‚îÇ   ‚îÇ   index.php
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄdocs
‚îÇ           openapi.yaml
‚îÇ
‚îú‚îÄ‚îÄ‚îÄroutes
‚îÇ       web.php
‚îÇ
‚îú‚îÄ‚îÄ‚îÄvendor
‚îÇ
‚îî‚îÄ‚îÄ‚îÄworker
        healthChecker.php
        statusOrderWorker.php
```
## üìù Entreg√°veis

- C√≥digo fonte completo no reposit√≥rio GitHub:
`https://github.com/AlanGiacomini/desafio-ipag`

- README.md detalhado com:
`este documento`
  - Instru√ß√µes de setup e execu√ß√£o
  - Documenta√ß√£o dos endpoints
  - Estrutura do projeto
  - Decis√µes t√©cnicas tomadas

- Plano de trabalho (tasks e estimativas)
`documento PDF na pasta DOCUMENTOS DO PROJETO neste reposit√≥rio`
- Docker Compose funcional
`docker-compose.yml`

- Migrations do banco de dados
`arquivos localizados em /migrations`

  > OBS: docker-compose j√° executa migrate.php (e as migrations) ao subir o conteiner.

- Collection do Postman/Insomnia para testes
`collection localizada na pasta DOCUMENTOS DO PROJETO`

## üìñ Instru√ß√µes de Execu√ß√£o do Projeto

### Requisitos

- Docker e Docker Compose instalados

- Git instalado

### Passo a passo

1 - Clone o reposit√≥rio:

```
git clone https://github.com/AlanGiacomini/desafio-ipag
cd desafio-ipag
```
2 - Construa e inicie os servi√ßos:

```
docker-compose up -d --build
```
3 - Verifique se os servi√ßos est√£o rodando:

```
docker ps
```
4 - Voc√™ deve ver os cont√™ineres:

    ipag-api (API REST)

    ipag-db (MySQL)

    ipag-rabbitmq (RabbitMQ)

    ipag-worker (Worker de notifica√ß√£o)

    migrator (executa as migrations)

5 - Acesse o RabbitMQ Management:

    URL: http://localhost:15672
    Usu√°rio: guest
    Senha: guest

6 - Teste os endpoints da API

Voc√™ pode usar Postman ou Insomnia. Uma collection de exemplo est√° dispon√≠vel no reposit√≥rio nas pasta DOCUMENTOS DO PROJETO.

### Encerramento dos servi√ßos:

```
docker-compose down
```


## üìÑ Documenta√ß√£o da API

### Endpoints REST dispon√≠veis

- **POST /auth/token:** Cria token jwt a partir do envio da API-Key
- **POST /orders:** Cria um novo pedido
- **GET /orders/{order_id}:** Consulta pedido espec√≠fico
- **PUT /orders/{order_id}/status:** Atualiza status do pedido
- **GET /orders:** Lista pedidos (com filtros opcionais)
- **GET /orders/summary:** Resumo estat√≠stico dos pedidos
- **GET /health:** Realiza verifica√ß√µes de conectividade com os servi√ßos que a API consome diretamente

---

### üîí  Endpoint de Autentica√ß√£o

#### ‚û°Ô∏è Gerar Token de Acesso

- **Endpoint:** `POST /auth/token`
- **Headers:** `x-api-key: SUA_API_KEY`
- **Descri√ß√£o:** Gera um token JWT para autentica√ß√£o nas rotas protegidas.

#### Exemplo de Requisi√ß√£o

```http
POST /auth/token
x-api-key: SUA_API_KEY
```

#### Exemplo de Resposta

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

---

### üõ†Ô∏è Endpoints de Pedidos (`/orders`)  
**Todas as rotas abaixo exigem o header:**  
`Authorization: Bearer {token}`

### ‚û°Ô∏è Listar Pedidos

- **Endpoint:** `GET /orders`
- **Descri√ß√£o:** Lista pedidos com filtros opcionais.

#### Par√¢metros de Consulta (query string)

- `id`: int
- `customer_id`: int
- `order_number`: string
- `status`: PENDING, WAITING_PAYMENT, PAID, PROCESSING, SHIPPED, DELIVERED, CANCELED
- `date_from`: datetime (YYYY-MM-DD)
- `date_to`: datetime (YYYY-MM-DD)
- `min_value`: float
- `max_value`: float

#### Exemplo

```http
GET /orders?status=PAID&min_value=100
Authorization: Bearer {token}
```

#### Exemplo de Resposta

```json
[
  {
    "order_id": "ORD-123456",
    "order_number": "ORD-123456",
    "status": "PAID",
    "total_value": 150.00,
    "customer": {
      "id": 1,
      "name": "Jo√£o",
      "document": "12345678900",
      "email": "joao@email.com",
      "phone": "11999999999",
      "created_at": "2025-08-28 20:22:01"
    },
    "items": [
      {
        "id": 1,
        "order_id": 5,
        "product_name": "Produto A",
        "quantity": 2,
        "unit_value": 50,
        "total_value": 100
      }
    ],
    "created_at": "2024-06-01T12:00:00Z"
  }
]
```

---

### ‚û°Ô∏è Criar Pedido

- **Endpoint:** `POST /orders`
- **Descri√ß√£o:** Cria um novo pedido.

#### Corpo da Requisi√ß√£o (JSON)

```json
{
  "customer": {
    "id": 2,
    "name": "Jo√£o",
    "document": "12345678900",
    "email": "joao@email.com",
    "phone": "11999999999"
  },
  "order": {
    "total_value": 150.00,
    "items": [
      {
        "product_name": "Produto A",
        "quantity": 2,
        "unit_value": 50
      }
    ]
  }
}
```

#### Exemplo de Resposta

```json
{
  "order_id": "ORD-123456",
  "order_number": "ORD-123456",
  "status": "PENDING",
  "total_value": 100,
  "customer": {
    "id": 1,
    "name": "Jo√£o",
    "document": "12345678900",
    "email": "joao@email.com",
    "phone": "11999999999",
    "created_at": "2025-08-28 20:22:01"
  },
  "items": [
    {
      "product_name": "Produto A",
      "quantity": 2,
      "unit_value": 50,
      "total_value": 100
    }
  ],
  "created_at": "2024-06-01T12:00:00Z"
}
```

---

### ‚û°Ô∏è Detalhes de um Pedido

- **Endpoint:** `GET /orders/{order_id}`
- **Descri√ß√£o:** Retorna os detalhes de um pedido pelo n√∫mero.

#### Exemplo

```http
GET /orders/ORD-123456
Authorization: Bearer {token}
```

#### Exemplo de Resposta

```json
{
  "order_id": "ORD-123456",
  "order_number": "ORD-123456",
  "status": "PAID",
  "total_value": 150.00,
  "customer": {
    "id": 1,
    "name": "Jo√£o",
    "document": "12345678900",
    "email": "joao@email.com",
    "phone": "11999999999"
  },
  "items": [
    {
      "id": 9,
      "order_id": 9,
      "product_name": "Produto A",
      "quantity": 2,
      "unit_value": 50,
      "total_value": 100
    }
  ],
  "created_at": "2024-06-01T12:00:00Z"
}
```

---

### ‚û°Ô∏è Resumo dos Pedidos

- **Endpoint:** `GET /orders/summary`
- **Descri√ß√£o:** Retorna estat√≠sticas dos pedidos.

#### Exemplo

```http
GET /orders/summary
Authorization: Bearer {token}
```

#### Exemplo de Resposta

```json
{
  "total_orders": 10,
  "total_value": 1500.00,
  "average_order_value": 150.00,
  "status_breakdown": {
    "PENDING": 2,
    "PAID": 5,
    "DELIVERED": 3
  }
}
```

---

### ‚û°Ô∏è Atualizar Status do Pedido

- **Endpoint:** `PUT /orders/{order_id}/status`
- **Descri√ß√£o:** Atualiza o status do pedido (processamento ass√≠ncrono).

#### Corpo da Requisi√ß√£o (JSON)

```json
{
  "status": "PAID",
  "notes": "Pagamento confirmado"
}
```

#### Exemplo

```http
PUT /orders/ORD-123456/status
Authorization: Bearer {token}
Content-Type: application/json
```

#### Exemplo de Resposta

```json
{
  "message": "Status enviado para processamento.",
  "order_id": "ORD-123456",
  "old_status": "WAITING_PAYMENT",
  "new_status": "PAID"
}
```
---
### ü©∫ Health check para API
>Esta rota n√£o precisa de Authorization: Bearer {token}

- **Endpoint:** `GET /health`
- **Descri√ß√£o:** Realiza verifica√ß√µes de conectividade com os servi√ßos que a API consome diretamente.
  - Banco de dados (MySQL)
  - Redis (utilizado para controle de requisi√ß√µes)
  - RabbitMQ (fila de mensageria)

- Esse endpoint retorna um JSON com o status de cada servi√ßo, permitindo que orquestradores, load balancers ou ferramentas de monitoramento identifiquem falhas rapidamente.

#### Exemplo

```http
GET /health
```
#### Exemplo de Resposta

```json
{
  "api": "ok",
  "database": "ok",
  "redis": "ok",
  "rabbitmq": "ok"
}
```

## Observa√ß√µes

- Todos os endpoints retornam JSON.
- Para gerar token, utilize o endpoint `/auth/token` com o header `x-api-key`.
- Para rotas protegidas, envie o header `Authorization: Bearer {token}`.

---
## üß† Decis√µes T√©cnicas

### ‚ûñ Arquitetura do sistema

A arquitetura segue o padr√£o MVC adaptado para APIs REST, com separa√ß√£o clara entre rotas, controllers, servi√ßos, modelos e persist√™ncia. A l√≥gica de neg√≥cio foi isolada na camada de servi√ßos, e o processamento ass√≠ncrono √© tratado por workers desacoplados via RabbitMQ.

### ‚ûñ Justificativas das depend√™ncias utilizadas

- **slim/slim** 
>microframework leve para cria√ß√£o de rotas e estrutura√ß√£o da API REST.
- **php-di/php-di** 
>gerenciador de depend√™ncias que facilita a inje√ß√£o de servi√ßos e modelos.
- **vlucas/phpdotenv** 
>carrega vari√°veis de ambiente de forma segura via arquivo .env.
- **firebase/php-jwt** 
>gera e valida tokens JWT para autentica√ß√£o segura.
- **php-amqplib/php-amqplib** 
>integra a aplica√ß√£o com RabbitMQ usando protocolo AMQP.
- **slim/psr7** 
>implementa√ß√£o PSR-7 para lidar com requisi√ß√µes e respostas HTTP no Slim.
- **predis/predis** 
>cliente Redis para PHP, usado em funcionalidades como rate limiting.
- **zircote/swagger-php** 
>gera documenta√ß√£o Swagger/OpenAPI diretamente das anota√ß√µes no c√≥digo.
- **doctrine/annotations** 
>interpreta as anota√ß√µes utilizadas pelo Swagger-PHP.
- **bcmath** 
>extens√£o nativa do PHP usada por bibliotecas como firebase/php-jwt.
- **pdo** 
>ativa a interface PDO (PHP Data Objects), que permite acesso seguro e orientado a objetos a bancos de dados.
- **pdo_mysql** 
>habilita o driver espec√≠fico para conex√£o PDO com MySQL/MariaDB, essencial para persist√™ncia dos dados da API.

### ‚ûñ Cadastro de Cliente ao lan√ßar novo Pedido

O endpoint  permite o envio de dados completos do cliente. Caso o cliente n√£o exista (por id ou documento), o sistema realiza o cadastro automaticamente. Essa abordagem foi adotada considerando cen√°rios em que o pedido √© gerado diretamente por um app ou sistema que realiza o onboarding do cliente no mesmo fluxo.

### ‚ûñ Seguran√ßa nas Rotas

As rotas foram estruturadas com dois grupos distintos a fim de mostrar a utiliza√ß√£o de 2 medidas de seguran√ßa diferentes, mas complementares:
Verifica√ß√£o de API Key e verifica√ß√£o de Token Gerado.

```php
// Rotas protegidas por API-Key
$app->group('/auth', function ($group) {
    $group->post('/token', AuthController::class . ':generateToken');
})->add(new ApiKeyMiddleware());

// Rotas protegidas por JWT
$app->group('/orders', function ($group) {
    $group->get('', OrderController::class . ':list');
    $group->post('', OrderController::class . ':create');
    $group->get('/summary', OrderController::class . ':summary');
    $group->get('/{order_id}', OrderController::class . ':get');
    $group->put('/{order_id}/status', OrderController::class . ':updateStatus');
})->add(new JwtMiddleware());
```

Essa estrutura foi deixada pronta para permitir a identifica√ß√£o da aplica√ß√£o acessando a API via "API Key" e do usu√°rio logado via "JWT", caso o projeto evolua para m√∫ltiplos clientes ou autentica√ß√£o por usu√°rio final.

### ‚ûñ Identificador de pedidos nas rotas

Em APIs √© uma boa pr√°tica usar identificadores externos e leg√≠veis nas rotas, como:
- ORD-12345 para pedidos;
Isso evita expor IDs internos das tabelas do banco de dados e facilita rastreabilidade.

### ‚ûñ Assinatura do m√©todo "summary" em OrderController

Utilizar o prefixo _ (underscore) em um nome de vari√°vel, como em $_request, √© uma conven√ß√£o comum e uma boa pr√°tica no PHP. Isso sinaliza para outros desenvolvedores, e at√© para ferramentas de an√°lise de c√≥digo, que:

- O par√¢metro √© necess√°rio na assinatura da fun√ß√£o (nesse caso, porque o framework Slim exige).

- A vari√°vel √© propositalmente ignorada dentro do corpo da fun√ß√£o.

Essa pr√°tica ajuda a evitar warnings ou erros de linting sobre "vari√°vel n√£o utilizada", que s√£o comuns em IDEs e ferramentas de qualidade de c√≥digo. √â uma maneira clara de expressar a inten√ß√£o e manter o c√≥digo limpo e sem alertas desnecess√°rios.

### ‚ûñ Cria√ß√£o de QueueService.php
Ao desacoplar o publishToQueue para um QueueService:

- **Separa responsabilidades**: o OrderService cuida da l√≥gica de pedidos, enquanto o QueueService cuida da mensageria.
- **Facilita testes**: √© poss√≠vel mockar o QueueService em testes unit√°rios.
- **Ganha flexibilidade**: se futuramente quiser publicar em outra fila, outro exchange, ou at√© outro broker (Kafka, Redis Streams), s√≥ alterar o QueueService.
- **Cria espa√ßo para reuso**: outros servi√ßos (ex: cancelamento, faturamento, envio de e-mails) podem usar o mesmo publisher.

### ‚ûñ Valida√ß√£o de transi√ß√£o de status do pedido no Service e n√£o no Worker

A valida√ß√£o das transi√ß√µes de status foi implementada diretamente na API, antes da publica√ß√£o da mensagem na fila RabbitMQ. Essa decis√£o foi tomada com base nos seguintes crit√©rios:

- Feedback imediato ao cliente: ao validar a transi√ß√£o na API, o usu√°rio recebe uma resposta r√°pida caso a opera√ß√£o seja inv√°lida, evitando frustra√ß√µes ou d√∫vidas sobre o processamento.
- Redu√ß√£o de carga no Worker: ao garantir que apenas mensagens v√°lidas sejam publicadas, o Worker pode se concentrar exclusivamente na execu√ß√£o das a√ß√µes, sem precisar lidar com valida√ß√µes complexas.
- Evita polui√ß√£o da fila: mensagens inv√°lidas n√£o s√£o enviadas, o que reduz a necessidade de tratamento de erros, Dead Letter Queues ou reprocessamentos desnecess√°rios.
- Melhor experi√™ncia de desenvolvimento: centralizar a valida√ß√£o na API facilita testes manuais e automatizados, al√©m de tornar o fluxo mais previs√≠vel.

Essa abordagem foi escolhida por priorizar a clareza, simplicidade e controle no ponto de entrada do sistema, mantendo o Worker como executor de a√ß√µes previamente validadas.

### ‚ûñ Estrutura da tabela de logs

A estrutura da tabela notification_logs foi adaptada para suportar logs sem√¢nticos e estruturados, com campos espec√≠ficos para n√≠vel (level) e contexto adicional (context) em formato JSON. Essa abordagem facilita exporta√ß√µes, auditoria, e integra√ß√£o futura com ferramentas de monitoramento.

### ‚ûñ Uso do Redis no Rate Limiting

O Redis foi adotado como mecanismo de controle de requisi√ß√µes (Rate Limiting) para garantir escalabilidade, consist√™ncia e performance em ambientes distribu√≠dos. Diferente de abordagens que armazenam requisi√ß√µes em mem√≥ria local (como arrays est√°ticos), o Redis permite que m√∫ltiplos containers ou processos compartilhem o mesmo estado de controle, evitando inconsist√™ncias e garantindo que o limite seja respeitado globalmente.

Al√©m disso, o Redis oferece estruturas como Sorted Sets, que facilitam a implementa√ß√£o de janelas deslizantes (sliding window), removendo requisi√ß√µes antigas e contabilizando apenas as recentes. Essa abordagem √© especialmente √∫til em ambientes com Docker Compose, onde m√∫ltiplas inst√¢ncias da aplica√ß√£o podem estar em execu√ß√£o simult√¢nea.

Com isso, o sistema se torna mais robusto contra abusos, ataques de nega√ß√£o de servi√ßo (DoS) e garante uma experi√™ncia mais est√°vel para todos os usu√°rios.


## üîí Diferenciais Implementados

### üîí Nivel 1 - Valida√ß√£o robusta de dados de entrada

A classe `Validator` foi criada para centralizar e padronizar a valida√ß√£o de dados recebidos pela API. Em vez de espalhar valida√ß√µes por controllers e services, essa abordagem oferece:

- **Reutiliza√ß√£o de l√≥gica**: Um √∫nico ponto de valida√ß√£o pode ser usado em m√∫ltiplos endpoints.
- **Facilidade de testes**: M√©todos isolados facilitam testes unit√°rios.
- **Padroniza√ß√£o de respostas**: Todos os erros seguem o mesmo formato, com `code` e `message`, facilitando o tratamento no frontend.
- **Extensibilidade**: Novas regras podem ser adicionadas sem afetar o restante da aplica√ß√£o.

#### Valida√ß√£o de Valores

Os m√©todos `validateField` e `validateAllFields` foram implementados com base em regras comuns de integridade de dados, utilizando fun√ß√µes nativas do PHP e express√µes regulares. Cada erro √© retornado no formato:

```php
$errors['nome_do_campo'] = [
  'code' => 'invalid_email',
  'message' => 'E-mail inv√°lido.'
];
```
Essa estrutura foi escolhida para:

- Separar a l√≥gica de neg√≥cio da l√≥gica de valida√ß√£o
- Permitir internacionaliza√ß√£o (o frontend pode traduzir os c√≥digos)
- Facilitar debug e rastreamento
- Melhorar a experi√™ncia do consumidor da API

#### Valida√ß√£o de Par√¢metros permitidos

O m√©todo `validateAllowedKeys` foi criado para validar se os par√¢metros recebidos em uma requisi√ß√£o (geralmente via query string ou corpo JSON) est√£o dentro de um conjunto permitido. Ele evita que campos inesperados ou maliciosos sejam processados silenciosamente pela API.

#### Exemplo de resposta da API

```json
{
  "error": "Erro ao listar pedidos: Erro de valida√ß√£o nos filtros.",
  "invalid_keys": [
    "comanda"
  ],
  "invalid_values": {
    "status": [
      {
        "code": "value_not_allowed",
        "message": "Valor n√£o permitido."
      }
    ],
    "date_from": [
      {
        "code": "invalid_datetime",
        "message": "Formato de data inv√°lido (ISO 8601)."
      }
    ]
  }
}
```
### Vantagens dessa abordagem

- Seguran√ßa: evita que campos n√£o documentados sejam aceitos ou utilizados indevidamente
- Previsibilidade: garante que a API s√≥ processe dados esperados
- Facilidade de debug: retorna os nomes dos campos inv√°lidos de forma clara
- Complementa a valida√ß√£o de valores: enquanto  valida o conte√∫do,  valida a estrutura

### Exemplo de uso em GET /orders: Lista pedidos (com filtros opcionais)

```
$filters = $request->getQueryParams();

//Passa a lista de campos permitidos no GET
$invalidate['invalid_keys'] = Validator::validateAllowedKeys($filters, [
    'id',
    'customer_id',
    'order_number',
    'status',
    'date_from',
    'date_to',
    'min_value',
    'max_value'
]);

//Valida√ß√£o de valores
$rules = [
    'id' => 'integer|min:1',
    'customer_id' => 'integer|min:1',
    'order_number' => 'order_number',
    'status' => 'in:PENDING,WAITING_PAYMENT,PAID,PROCESSING,SHIPPED,DELIVERED,CANCELED',
    'date_from' => 'datetime',
    'date_to' => 'datetime',
    'min_value' => 'numeric|min:0',
    'max_value' => 'numeric|min:0'
];

$invalidate['invalid_values'] = Validator::validateAllFields($filters, $rules);
```
---
### üîí Nivel 1 - Logs estruturados em formato JSON

A tabela `notification_logs` foi criada com uma coluna `context` do tipo `JSON`, permitindo armazenar dados estruturados diretamente no banco:
```
context:
{
    "notes": "Pagamento confirmado via PIX",
    "user_id": "system",
    "order_id": 7,
    "created_at": "2025-08-28T21:48:29-03:00",
    "new_status": "SHIPPED",
    "old_status": "PROCESSING"
}
```
Isso garante que cada log de notifica√ß√£o possa conter metadados ricos e organizados, sem depender de parsing de texto ou campos adicionais.

Esse formato permite:
- Auditoria precisa: cada altera√ß√£o de status tem rastreabilidade completa.
- Consultas flex√≠veis: usando fun√ß√µes nativas do MySQL para JSON (JSON_EXTRACT, ->, etc.).
- Integra√ß√£o com ferramentas externas: como ELK, Grafana ou servi√ßos de monitoramento.

---
### üîí Nivel 1 - README detalhado com exemplos de uso

Corresponde a essa documenta√ß√£o README.md, especificamente na sess√£o "üìÑ Documenta√ß√£o da API".

---
### üîí Nivel 2 - Rate limiting b√°sico nos endpoints

Criado Middleware `RateLimitMiddlaware` para controle de limites de requisi√ß√µes:

- **Identifica√ß√£o do cliente**: usa `jwt_payload['user']` como chave prim√°ria. Se o token estiver ausente, usa o IP como fallback. O controle por usu√°rio √© √∫til para limitar por identidade (ex: admin, cliente123). Por outro lado poderia ser usado o controle por token, que √© √∫til se voc√™ quer isolar o Rate limit de cada sess√£o ou dispositivo.
- **Configura√ß√£o din√¢mica**: os limites s√£o definidos via `.env` com as vari√°veis `RATE_LIMIT_MAX` e `RATE_LIMIT_WINDOW`.
- **Controle por janela deslizante**: armazena timestamps das requisi√ß√µes e remove os que est√£o fora da janela. A cada requisi√ß√£o, o sistema olha para os √∫ltimos 60 segundos a partir do momento atual.
- **Resposta padr√£o**: retorna `429 Too Many Requests` com mensagem JSON estruturada.

#### Exemplo de `.env`

```env
RATE_LIMIT_MAX=50
RATE_LIMIT_WINDOW=60
```
#### Como aplicar nas rotas

```php
$app->group('/orders', function ($group) {
    // suas rotas protegidas
})->add(new JwtMiddleware())->add(new RateLimitMiddleware());
```

---

### üîí Nivel 2 - Health checks para API e Worker

A aplica√ß√£o implementa verificadores de sa√∫de independentes para a API e o Worker, permitindo monitoramento automatizado e valida√ß√£o da opera√ß√£o dos servi√ßos.

#### Health Check da API

A API exp√µe o endpoint `/health`, que pode ser acessado via HTTP. Ele realiza verifica√ß√µes de conectividade com os servi√ßos que a API consome diretamente:

- Banco de dados (MySQL)
- Redis (utilizado para controle de requisi√ß√µes)
- RabbitMQ (fila de mensageria)

Esse endpoint retorna um JSON com o status de cada servi√ßo, permitindo que orquestradores, load balancers ou ferramentas de monitoramento identifiquem falhas rapidamente.

**Exemplo de resposta:**

```json
{
  "api": "ok",
  "database": "ok",
  "redis": "ok",
  "rabbitmq": "ok"
}
```

#### Health Check do Worker

O Worker possui um script CLI localizado em `worker/healthCheck.php`, que pode ser executado manualmente ou por sistemas de monitoramento. Ele verifica:

- Conex√£o com o banco de dados
- Conex√£o com o RabbitMQ
- Exist√™ncia e status da fila `order_status_updates`

**Exemplo de execu√ß√£o:**

```bash
docker exec ipag-worker php worker/healthChecker.php
```

**Exemplo de sa√≠da:**

```json
{
  "worker": "ok",
  "database": "ok",
  "rabbitmq": "ok",
  "queue": "ok",
  "messages_pending": 3,
  "consumers": 1
}
```
---
### üîí Nivel 2 - API documentation (Swagger/OpenAPI)

A documenta√ß√£o foi gerada automaticamente a partir das anota√ß√µes no c√≥digo, facilitando a compreens√£o e o uso da API por desenvolvedores e integradores.

O arquivo localizado em 'public/docs/openapi.yaml' cont√©m a documenta√ß√£o OpenAPI do projeto.

---
### üîí Nivel 3 - Environment-based configuration

A aplica√ß√£o utiliza vari√°veis de ambiente para configurar dinamicamente aspectos como credenciais de banco de dados, chaves secretas, URLs externas e n√≠veis de log. Isso √© feito por meio da biblioteca vlucas/phpdotenv, que carrega o conte√∫do do arquivo .env e disponibiliza os valores via $_ENV. Essa abordagem permite flexibilidade entre ambientes (desenvolvimento, produ√ß√£o, testes), evita hardcode de informa√ß√µes sens√≠veis e facilita a automa√ß√£o de deploys e integra√ß√£o com Docker e CI/CD.

---
# üë®‚Äçüíª Autor: Alan Giacomini

üì´ **Contato**: [LinkedIn](https://www.linkedin.com/in/alangiacominisp/)







